{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LibreConga # This is a personal project for reversing the vacuum cleaner Conga communication protocol from Cecotec . At the moment I own one Conga model 5490. Info This work is purely educational and there is no intention to damage the image of Cecotec or their work. All work presented here is only for educational purposes. This work is based on the one done in https://blog.rastersoft.com/ . That work is for Conga 1490/1590. Note This work is still in progress so the content can change.","title":"Home"},{"location":"#libreconga","text":"This is a personal project for reversing the vacuum cleaner Conga communication protocol from Cecotec . At the moment I own one Conga model 5490. Info This work is purely educational and there is no intention to damage the image of Cecotec or their work. All work presented here is only for educational purposes. This work is based on the one done in https://blog.rastersoft.com/ . That work is for Conga 1490/1590. Note This work is still in progress so the content can change.","title":"LibreConga"},{"location":"research/commands/","text":"Commands # These are the commands for Conga. The values are represented as Little Endian, but they are transmited as Big Endian. OpCode (hex) OpCode (dec) Conga Comment 0x07 0xd5 2005 5490 Ping Request 0x07 0xd6 2006 5490 Ping Response 0x0b 0xb9 3001 5490 Login Request 0x0b 0xba 3002 5490 Login Response","title":"Commands"},{"location":"research/commands/#commands","text":"These are the commands for Conga. The values are represented as Little Endian, but they are transmited as Big Endian. OpCode (hex) OpCode (dec) Conga Comment 0x07 0xd5 2005 5490 Ping Request 0x07 0xd6 2006 5490 Ping Response 0x0b 0xb9 3001 5490 Login Request 0x0b 0xba 3002 5490 Login Response","title":"Commands"},{"location":"research/pairing/","text":"Pairing # Cecotect provides a bunch of mobile applications. There is like an application per model series. That suggests there are either potentially several protocol implementations or there is one protocol with hardware limitations (depending on the model) How Cecoted has designed the pairing between the mobile app and the Conga? # I am using the Conga 5000 app. Android: https://play.google.com/store/apps/details?id=es.cecotec.s5090&hl=es_419&gl=US iOS: https://apps.apple.com/es/app/conga-5000/id1469506857 The application asks for a lot of permissions, but that is not the point at the moment. Thus, the process requires you to connect the mobile to a Wireless net with Internet access. Hence, the pairing wizard asks you to give a Conga's name. Next, the application brings up the network SSID name so you can pick it up. Next, you can define the password. Finally, the applications do some connections and end pairing the Conga. That pairing allows the Conga to connect to the Wireless network with Internet access. Sniffing the pairing process # I configured a Raspberry Pi with a wireless AP so I can monitor all the traffic that goes through the wireless connection. Once I have that AP configured in the Raspberry Pi. I connect the mobile to that AP then I follow the pairing process. First, I filter DNS traffic and I can see there is an A query for the domain eulog.3irobotics.net . The answer gives a CNAME pointing to eu.log.3irobotics.net . That last FQDN has the following IP assigned: eu.log.3irobotics.net: type A, class IN, addr 8.211.48.101 eu.log.3irobotics.net: type A, class IN, addr 47.254.145.60 eu.log.3irobotics.net: type A, class IN, addr 47.91.87.185 eu.log.3irobotics.net: type A, class IN, addr 8.211.50.7 Second, I have to see any connections going to one of those IPs. The filter to apply in Wireshark is ip.dst == 47.254.145.60 || ip.dst == 47.91.87.185 || ip.dst == 8.211.50.7 || ip.dst == 8.211.48.101 . That brings up some TCP connections and TLSv1.2 . I highlighted the TLSv1.2 because that means the connections are encrypted, that is because the application uses HTTPS. Now, I have to see whether it is HTTPS or HSTS. If the app uses HTTPS I can bypass that easily, on the other hand, HSTS is much more difficult, but it can be bypassed anyway.","title":"Pairing the app"},{"location":"research/pairing/#pairing","text":"Cecotect provides a bunch of mobile applications. There is like an application per model series. That suggests there are either potentially several protocol implementations or there is one protocol with hardware limitations (depending on the model)","title":"Pairing"},{"location":"research/pairing/#how-cecoted-has-designed-the-pairing-between-the-mobile-app-and-the-conga","text":"I am using the Conga 5000 app. Android: https://play.google.com/store/apps/details?id=es.cecotec.s5090&hl=es_419&gl=US iOS: https://apps.apple.com/es/app/conga-5000/id1469506857 The application asks for a lot of permissions, but that is not the point at the moment. Thus, the process requires you to connect the mobile to a Wireless net with Internet access. Hence, the pairing wizard asks you to give a Conga's name. Next, the application brings up the network SSID name so you can pick it up. Next, you can define the password. Finally, the applications do some connections and end pairing the Conga. That pairing allows the Conga to connect to the Wireless network with Internet access.","title":"How Cecoted has designed the pairing between the mobile app and the Conga?"},{"location":"research/pairing/#sniffing-the-pairing-process","text":"I configured a Raspberry Pi with a wireless AP so I can monitor all the traffic that goes through the wireless connection. Once I have that AP configured in the Raspberry Pi. I connect the mobile to that AP then I follow the pairing process. First, I filter DNS traffic and I can see there is an A query for the domain eulog.3irobotics.net . The answer gives a CNAME pointing to eu.log.3irobotics.net . That last FQDN has the following IP assigned: eu.log.3irobotics.net: type A, class IN, addr 8.211.48.101 eu.log.3irobotics.net: type A, class IN, addr 47.254.145.60 eu.log.3irobotics.net: type A, class IN, addr 47.91.87.185 eu.log.3irobotics.net: type A, class IN, addr 8.211.50.7 Second, I have to see any connections going to one of those IPs. The filter to apply in Wireshark is ip.dst == 47.254.145.60 || ip.dst == 47.91.87.185 || ip.dst == 8.211.50.7 || ip.dst == 8.211.48.101 . That brings up some TCP connections and TLSv1.2 . I highlighted the TLSv1.2 because that means the connections are encrypted, that is because the application uses HTTPS. Now, I have to see whether it is HTTPS or HSTS. If the app uses HTTPS I can bypass that easily, on the other hand, HSTS is much more difficult, but it can be bypassed anyway.","title":"Sniffing the pairing process"},{"location":"research/protocol/","text":"Protocol # First of all, I'd like to mention something about SSL Pinning. After capturing the login process I felt like the traffic was not ciphered so I tried to login into the Conga app on another device, obviously, without installing any CA or rooting it. The traffic was the same, well it follows the same pattern. At the end of the day, all the stuff I set up for bypassing the SSL Pinning was useless, well I learned a lot, but nothing worth it for this case. That said, let's continue with the login protocol. Once the application is open, it starts sending ping messages to the server. Those messages are as following: 18 00 00 00 | 02 00 00 00 | 00 00 00 00 | 00 00 84 f2 | 38 34 41 30 | 6e 5d d5 07 I did a small research on the Internet and I found the BadConga project where the owner did some reversing on those pings. They are following a pattern described here . Length: 18 00 00 00 ctype: 02 00 flow: 00 00 user id: 00 00 00 00 device id: 00 00 84 f2 Sequence: 38 34 41 30 6e 5d OpCode: d5 07 It seems that 18 00 00 00 is the size of the data send back and forth. If I convert that into a decimal value it decodes as 24 00 00 00 . 24 is the number of bytes there are in the frame. But, this value is not 24 in decimal, that value is 24000000 so it must be encoded as little-endian . Decoding 18 00 00 00 as little-endian it makes more sense now. Login request # When I entered the credentials and hit login, the application sent soma data to the server. That data was as follows. 41 00 00 00 | 02 00 00 00 | 00 00 00 00 | 00 00 ee d7 | 49 34 41 30 | 6e 5d b9 0b | 0a 13 XX XX | XX XX XX XX | XX XX XX XX | XX XX XX XX | XX XX XX XX | XX 12 0f 3f | YY YY YY YY | YY YY YY YY | YY YY YY YY | YY 20 eb 07 I can see some pattern here, 41h is 65d , which is the exact amount of data that is in the packet. If I try to decode it as before... Legnth: 41 00 00 00 ctype: 02 00 flow: 00 00 user id: 00 00 00 00 device id: 00 00 ee d7 Sequence: 49 34 41 30 6e 5d OpCode: b9 0b Payload: 0a 13 XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX 12 0f 3f YY YY YY YY YY YY YY YY YY YY YY YY YY 20 eb 07 Where the bytes marked as XX are part of my account and bytes marked as YY belong to my password. I'd like to make some notes here. This is not a normal protocol as it could be Form POST or JSON, it seems to be a serialized protocol, but I don't know yet which one. It is weird to build up a new protocol, but there are crazy people around there. Another thing I noticed. The field device id changes on every ping request, and it could be even normal as no one has login yet. But, once logged in why is the application sending a completely different device id ? Well, let's see whether it changes once the Conga gets paired. Login response # Following my logic, the server response should follow the same protocol so let's dig into the reply from the server. Once more, I am going to split up the frame into chunks. Some of them have a meaning already, others are new. 4d 00 00 00 | 07 01 47 00 | 00 00 00 00 | 00 00 ee d7 | 49 34 41 30 | 6e 5d ba 0b | 08 00 1a 31 | 08 c3 be 28 | 12 20 SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS 18 01 | 28 00 32 05 | 08 eb 07 10 | 03 Arranging it a little bit. Length: 4d 00 00 00 ctype: 07 01 flow: 47 00 user id: 00 00 00 00 device id: 00 00 ee d7 Sequence: 49 34 41 30 6e 5d OpCode: ba 0b Payload: 08 00 1a 31 08 c3 be 28 12 20 SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS 18 01 28 00 32 05 08 eb 07 10 03 The bytes marked as SS belongs to something that seems to be a session token or similar. It is constructed from hexadecimal characters. All other characters seem to be some kind of context of wrapping data. But I don't have enough information to say something about them. Note: The Sequance is constant during the session, which means when the application is opened until it is closed. As I said, the device id changes on every request. And, the op code is an operation code. This is what I've got so far. Op Code Decimal Meaning 0xd5 0x07 2005 Client ping 0xd6 0x07 2006 Server ping response 0xb9 0x0b 3001 Login 0xba 0x0b 3002 Login successfull Protocol Buffers # After some digging, I found the protocol used in the payload or data section is Protocol Buffers . This is a binary protocol designed by Google . In terms to use this protocol, you must define how your message looks like and then compile that definition. Thus, you can use it in your applications. An example from the documentation's side. message Test1 { optional int32 a = 1; } You create a Test1 object and assign 150 to the a field. You then serialize the message to an output stream. If you were able to examine the encoded you'll see three bytes. 08 96 01 Here is the full documentation regarding Protocol Buffers. Reversing Protocol Buffers # Protocols Buffers are sent over the network as a binary stream of data so I need something to read that data and convert it into a readable object, something similar to JSON. There is a tool written in Python called blackboxprotobuf that can help me on this matter. Blackboxprotobuf is really easy to use. It exposes a method that requires a binary string as an argument as input. The method returns back a Python set, which can be treated as JSON object. Protocol buffers are reversed as key: value . But the key is not auto-explanatory, instead, the key is a number that is used when the data is defined just before it gets compiled. However, I can use whatever key I want in my data model definition as long as I assign the same field number . Login request # The login data was encoded in Protocol Buffers so using Blackboxprotobuf I can recover what the message was sent off to the server. Just to catch up, the login data was defined like: 0a 13 XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX 12 0f 3f YY YY YY YY YY YY YY YY YY YY YY YY YY 20 eb 07 The XX bytes are for the username and the YY bytes are the ones for the password. But there is more information not visible in plain text. After running the Blackboxprotocol I could see another field. { '1': b'email@addres.com', '2': b'<password>', '4': 1003 } From here I know that the Protocol buffers model for the login request should be something similar to this: message LoginRequest { required string email = 1; required string password = 2; required int32 unknown = 4; } Login responses # Following the same approach, I decoded the data received as a response from the login request, and as well as the login request I was able to see more fields. The data returned from the server. 08 00 1a 31 08 c3 be 28 12 20 SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS 18 01 28 00 32 05 08 eb 07 10 03 SS bytes are the ones for the session token I could identify as they were in plain text. This is what Blackboxprotobuf could identify. { '1': 0, '3': { '1': UUUUUU, '2': b'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', '3': 1, '5': 0, '6': { '1': 1003, '2': 3 } } } Clearly, the data was hiding more info than expected. I classified UU as the user ID , but I don't know yet. Note The following requests and responses had the value UserID in the header populated with the value UUUUUU . Thus, field 3.1 is the user identification. Now what I can see is that the login response data model is something like. message LoginResponse { message Unknown { required int32 unknown1 = 1; required int32 unknown2 = 2; } message Msg { required int32 user_id = 1; required string session = 2; required int32 unknown = 3; required int32 unknown1 = 5; required Unknown unknown2 = 6; } required int32 unknown = 1; required Msg msg = 3; } Subsequent request/responses # Now, I know how to decode the Protocol Buffers so reading the data and parsing as Protocol Buffers is not an issue anymore. The problem is to identify all the field meaning. This is usually a try and failure and sees what changes on each request by doing A or B . Just after the login success response from the server, the application did another call to the server with the following data. { '1': b'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', '2': 1, '3': 1003, '4': 1003, '5': b'1.1.21' } Fron this request I got that the application was using the session returned by the server on the login success. The application also sends some other values that I don't understand, but there is one '5': b'1.1.21' which is the application version. On the other hand, the interesting thing here is the command opcode used to send that amount of data. The opcode is 0x7d1 . This code seems to be a client identification or something similar. I didn't receive any response, instead, the app did another request. { '1': UUUUUU, '2': b'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', '3': 23 } This time the opcode was 0xbcb and it seems to be a kind of ping or keepalive. Another opcode sent to the server was 0xbe5 . As per the information sent it seems to be just a remainder for the application version. { '1': 1, '2': 1003, '3': b'1.1.21' }","title":"Protocol"},{"location":"research/protocol/#protocol","text":"First of all, I'd like to mention something about SSL Pinning. After capturing the login process I felt like the traffic was not ciphered so I tried to login into the Conga app on another device, obviously, without installing any CA or rooting it. The traffic was the same, well it follows the same pattern. At the end of the day, all the stuff I set up for bypassing the SSL Pinning was useless, well I learned a lot, but nothing worth it for this case. That said, let's continue with the login protocol. Once the application is open, it starts sending ping messages to the server. Those messages are as following: 18 00 00 00 | 02 00 00 00 | 00 00 00 00 | 00 00 84 f2 | 38 34 41 30 | 6e 5d d5 07 I did a small research on the Internet and I found the BadConga project where the owner did some reversing on those pings. They are following a pattern described here . Length: 18 00 00 00 ctype: 02 00 flow: 00 00 user id: 00 00 00 00 device id: 00 00 84 f2 Sequence: 38 34 41 30 6e 5d OpCode: d5 07 It seems that 18 00 00 00 is the size of the data send back and forth. If I convert that into a decimal value it decodes as 24 00 00 00 . 24 is the number of bytes there are in the frame. But, this value is not 24 in decimal, that value is 24000000 so it must be encoded as little-endian . Decoding 18 00 00 00 as little-endian it makes more sense now.","title":"Protocol"},{"location":"research/protocol/#login-request","text":"When I entered the credentials and hit login, the application sent soma data to the server. That data was as follows. 41 00 00 00 | 02 00 00 00 | 00 00 00 00 | 00 00 ee d7 | 49 34 41 30 | 6e 5d b9 0b | 0a 13 XX XX | XX XX XX XX | XX XX XX XX | XX XX XX XX | XX XX XX XX | XX 12 0f 3f | YY YY YY YY | YY YY YY YY | YY YY YY YY | YY 20 eb 07 I can see some pattern here, 41h is 65d , which is the exact amount of data that is in the packet. If I try to decode it as before... Legnth: 41 00 00 00 ctype: 02 00 flow: 00 00 user id: 00 00 00 00 device id: 00 00 ee d7 Sequence: 49 34 41 30 6e 5d OpCode: b9 0b Payload: 0a 13 XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX 12 0f 3f YY YY YY YY YY YY YY YY YY YY YY YY YY 20 eb 07 Where the bytes marked as XX are part of my account and bytes marked as YY belong to my password. I'd like to make some notes here. This is not a normal protocol as it could be Form POST or JSON, it seems to be a serialized protocol, but I don't know yet which one. It is weird to build up a new protocol, but there are crazy people around there. Another thing I noticed. The field device id changes on every ping request, and it could be even normal as no one has login yet. But, once logged in why is the application sending a completely different device id ? Well, let's see whether it changes once the Conga gets paired.","title":"Login request"},{"location":"research/protocol/#login-response","text":"Following my logic, the server response should follow the same protocol so let's dig into the reply from the server. Once more, I am going to split up the frame into chunks. Some of them have a meaning already, others are new. 4d 00 00 00 | 07 01 47 00 | 00 00 00 00 | 00 00 ee d7 | 49 34 41 30 | 6e 5d ba 0b | 08 00 1a 31 | 08 c3 be 28 | 12 20 SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS SS SS | SS SS 18 01 | 28 00 32 05 | 08 eb 07 10 | 03 Arranging it a little bit. Length: 4d 00 00 00 ctype: 07 01 flow: 47 00 user id: 00 00 00 00 device id: 00 00 ee d7 Sequence: 49 34 41 30 6e 5d OpCode: ba 0b Payload: 08 00 1a 31 08 c3 be 28 12 20 SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS 18 01 28 00 32 05 08 eb 07 10 03 The bytes marked as SS belongs to something that seems to be a session token or similar. It is constructed from hexadecimal characters. All other characters seem to be some kind of context of wrapping data. But I don't have enough information to say something about them. Note: The Sequance is constant during the session, which means when the application is opened until it is closed. As I said, the device id changes on every request. And, the op code is an operation code. This is what I've got so far. Op Code Decimal Meaning 0xd5 0x07 2005 Client ping 0xd6 0x07 2006 Server ping response 0xb9 0x0b 3001 Login 0xba 0x0b 3002 Login successfull","title":"Login response"},{"location":"research/protocol/#protocol-buffers","text":"After some digging, I found the protocol used in the payload or data section is Protocol Buffers . This is a binary protocol designed by Google . In terms to use this protocol, you must define how your message looks like and then compile that definition. Thus, you can use it in your applications. An example from the documentation's side. message Test1 { optional int32 a = 1; } You create a Test1 object and assign 150 to the a field. You then serialize the message to an output stream. If you were able to examine the encoded you'll see three bytes. 08 96 01 Here is the full documentation regarding Protocol Buffers.","title":"Protocol Buffers"},{"location":"research/protocol/#reversing-protocol-buffers","text":"Protocols Buffers are sent over the network as a binary stream of data so I need something to read that data and convert it into a readable object, something similar to JSON. There is a tool written in Python called blackboxprotobuf that can help me on this matter. Blackboxprotobuf is really easy to use. It exposes a method that requires a binary string as an argument as input. The method returns back a Python set, which can be treated as JSON object. Protocol buffers are reversed as key: value . But the key is not auto-explanatory, instead, the key is a number that is used when the data is defined just before it gets compiled. However, I can use whatever key I want in my data model definition as long as I assign the same field number .","title":"Reversing Protocol Buffers"},{"location":"research/protocol/#login-request_1","text":"The login data was encoded in Protocol Buffers so using Blackboxprotobuf I can recover what the message was sent off to the server. Just to catch up, the login data was defined like: 0a 13 XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX 12 0f 3f YY YY YY YY YY YY YY YY YY YY YY YY YY 20 eb 07 The XX bytes are for the username and the YY bytes are the ones for the password. But there is more information not visible in plain text. After running the Blackboxprotocol I could see another field. { '1': b'email@addres.com', '2': b'<password>', '4': 1003 } From here I know that the Protocol buffers model for the login request should be something similar to this: message LoginRequest { required string email = 1; required string password = 2; required int32 unknown = 4; }","title":"Login request"},{"location":"research/protocol/#login-responses","text":"Following the same approach, I decoded the data received as a response from the login request, and as well as the login request I was able to see more fields. The data returned from the server. 08 00 1a 31 08 c3 be 28 12 20 SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS 18 01 28 00 32 05 08 eb 07 10 03 SS bytes are the ones for the session token I could identify as they were in plain text. This is what Blackboxprotobuf could identify. { '1': 0, '3': { '1': UUUUUU, '2': b'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', '3': 1, '5': 0, '6': { '1': 1003, '2': 3 } } } Clearly, the data was hiding more info than expected. I classified UU as the user ID , but I don't know yet. Note The following requests and responses had the value UserID in the header populated with the value UUUUUU . Thus, field 3.1 is the user identification. Now what I can see is that the login response data model is something like. message LoginResponse { message Unknown { required int32 unknown1 = 1; required int32 unknown2 = 2; } message Msg { required int32 user_id = 1; required string session = 2; required int32 unknown = 3; required int32 unknown1 = 5; required Unknown unknown2 = 6; } required int32 unknown = 1; required Msg msg = 3; }","title":"Login responses"},{"location":"research/protocol/#subsequent-requestresponses","text":"Now, I know how to decode the Protocol Buffers so reading the data and parsing as Protocol Buffers is not an issue anymore. The problem is to identify all the field meaning. This is usually a try and failure and sees what changes on each request by doing A or B . Just after the login success response from the server, the application did another call to the server with the following data. { '1': b'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', '2': 1, '3': 1003, '4': 1003, '5': b'1.1.21' } Fron this request I got that the application was using the session returned by the server on the login success. The application also sends some other values that I don't understand, but there is one '5': b'1.1.21' which is the application version. On the other hand, the interesting thing here is the command opcode used to send that amount of data. The opcode is 0x7d1 . This code seems to be a client identification or something similar. I didn't receive any response, instead, the app did another request. { '1': UUUUUU, '2': b'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', '3': 23 } This time the opcode was 0xbcb and it seems to be a kind of ping or keepalive. Another opcode sent to the server was 0xbe5 . As per the information sent it seems to be just a remainder for the application version. { '1': 1, '2': 1003, '3': b'1.1.21' }","title":"Subsequent request/responses"},{"location":"research/recon/","text":"Reconnaissance # First things first, if I want to get into the Conga, I have to see what services are exposed from Conga. Second, I'll have to see how the application sends the pairing information to the Conga. Booting up the Conga Wireless AP # To start the AP service in the Conga you must have to press the power + mode buttons for at least 3 seconds. After 3 seconds the Conga will emit a blinky sound. The AP's SSID matches this pattern: Conga<Model>_XXXXXX , where <Model> is the type of the Conga and XXXXXX is a number, potentially a random number. This AP has no password so you can connect to it easily. NOTE: This process might differ among Conga models. Scanning services # Once connected I check what IP I've got assigned. Running ifconfig or ip a will be more than enough to check the wireless interface. I've got assigned 192.168.5.2 so commonly the gateway will be 192.168.5.1 . However, using nmap we can find the available host in the net. sudo nmap -sn 192.168.5.0/24 Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-19 20:41 CET Nmap scan report for 192.168.5.1 Host is up (0.0073s latency). MAC Address: <redacted> (<redacted>) Nmap scan report for my-host (192.168.5.2) Host is up. Nmap done: 256 IP addresses (2 hosts up) scanned in 15.00 seconds NOTE: I redacted some bits for the sake of privacy. Now, I already know where is the AP. It is at 192.168.5.1 as I already guessed. The next step is to find out what services are available. Again, using nmap it is quite easy to find out the list of services. sudo nmap -p- 192.168.5.1 Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-19 20:45 CET Nmap scan report for 192.168.5.1 Host is up (0.0034s latency). Not shown: 65530 closed ports PORT STATE SERVICE 22/tcp open ssh 53/tcp open domain 6000/tcp open X11 6008/tcp open X11:8 8111/tcp open skynetflow MAC Address: <redacted> (<redacted>) Nmap done: 1 IP address (1 host up) scanned in 23.77 seconds NOTE: I redacted some bits for the sake of privacy. Well, I dig a little bit more into the ports and I got the following output. sudo nmap -sV -p22,53,6000,6008,8111 192.168.5.1 Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-19 20:55 CET Nmap scan report for 192.168.5.1 Host is up (0.33s latency). PORT STATE SERVICE VERSION 22/tcp open ssh Dropbear sshd 2015.71 (protocol 2.0) 53/tcp open domain dnsmasq 2.75 6000/tcp open X11? 6008/tcp open X11:8? 8111/tcp open skynetflow? Port 22 is quite interesting but I need a user and password. Checking for vulnerabilities I can see Dropbear version 2015.71 has 3 CVE and 2 of them remote and quite interesting. I was unable to exploit the vulnerabilities regarding Dropbear. I didn't find an exploit for CVE-2017-9078 and I found an exploit for CVE-2016-3116, it could be due to the exploit didn't work or the most probable it is due to my lack of knowledge in the pentesting area. On the other hand, port 53 is also open so let's try to see whether it translate domain names. Using the short options. dig +short localhost @192.168.5.1 127.0.0.1 Using the long options. dig localhost @192.168.5.1 ; <<>> DiG 9.10.6 <<>> localhost @192.168.5.1 ;; global options: +cmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 11050 ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1280 ;; QUESTION SECTION: ;localhost. IN A ;; ANSWER SECTION: localhost. 0 IN A 127.0.0.1 ;; Query time: 1 msec ;; SERVER: 192.168.5.1#53(192.168.5.1) ;; WHEN: Fri Feb 19 21:35:29 CET 2021 ;; MSG SIZE rcvd: 54 Lastly, I was unable to get more information about ports 6000, 6008, and 8111.","title":"Recon the Conga"},{"location":"research/recon/#reconnaissance","text":"First things first, if I want to get into the Conga, I have to see what services are exposed from Conga. Second, I'll have to see how the application sends the pairing information to the Conga.","title":"Reconnaissance"},{"location":"research/recon/#booting-up-the-conga-wireless-ap","text":"To start the AP service in the Conga you must have to press the power + mode buttons for at least 3 seconds. After 3 seconds the Conga will emit a blinky sound. The AP's SSID matches this pattern: Conga<Model>_XXXXXX , where <Model> is the type of the Conga and XXXXXX is a number, potentially a random number. This AP has no password so you can connect to it easily. NOTE: This process might differ among Conga models.","title":"Booting up the Conga Wireless AP"},{"location":"research/recon/#scanning-services","text":"Once connected I check what IP I've got assigned. Running ifconfig or ip a will be more than enough to check the wireless interface. I've got assigned 192.168.5.2 so commonly the gateway will be 192.168.5.1 . However, using nmap we can find the available host in the net. sudo nmap -sn 192.168.5.0/24 Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-19 20:41 CET Nmap scan report for 192.168.5.1 Host is up (0.0073s latency). MAC Address: <redacted> (<redacted>) Nmap scan report for my-host (192.168.5.2) Host is up. Nmap done: 256 IP addresses (2 hosts up) scanned in 15.00 seconds NOTE: I redacted some bits for the sake of privacy. Now, I already know where is the AP. It is at 192.168.5.1 as I already guessed. The next step is to find out what services are available. Again, using nmap it is quite easy to find out the list of services. sudo nmap -p- 192.168.5.1 Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-19 20:45 CET Nmap scan report for 192.168.5.1 Host is up (0.0034s latency). Not shown: 65530 closed ports PORT STATE SERVICE 22/tcp open ssh 53/tcp open domain 6000/tcp open X11 6008/tcp open X11:8 8111/tcp open skynetflow MAC Address: <redacted> (<redacted>) Nmap done: 1 IP address (1 host up) scanned in 23.77 seconds NOTE: I redacted some bits for the sake of privacy. Well, I dig a little bit more into the ports and I got the following output. sudo nmap -sV -p22,53,6000,6008,8111 192.168.5.1 Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-19 20:55 CET Nmap scan report for 192.168.5.1 Host is up (0.33s latency). PORT STATE SERVICE VERSION 22/tcp open ssh Dropbear sshd 2015.71 (protocol 2.0) 53/tcp open domain dnsmasq 2.75 6000/tcp open X11? 6008/tcp open X11:8? 8111/tcp open skynetflow? Port 22 is quite interesting but I need a user and password. Checking for vulnerabilities I can see Dropbear version 2015.71 has 3 CVE and 2 of them remote and quite interesting. I was unable to exploit the vulnerabilities regarding Dropbear. I didn't find an exploit for CVE-2017-9078 and I found an exploit for CVE-2016-3116, it could be due to the exploit didn't work or the most probable it is due to my lack of knowledge in the pentesting area. On the other hand, port 53 is also open so let's try to see whether it translate domain names. Using the short options. dig +short localhost @192.168.5.1 127.0.0.1 Using the long options. dig localhost @192.168.5.1 ; <<>> DiG 9.10.6 <<>> localhost @192.168.5.1 ;; global options: +cmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 11050 ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1280 ;; QUESTION SECTION: ;localhost. IN A ;; ANSWER SECTION: localhost. 0 IN A 127.0.0.1 ;; Query time: 1 msec ;; SERVER: 192.168.5.1#53(192.168.5.1) ;; WHEN: Fri Feb 19 21:35:29 CET 2021 ;; MSG SIZE rcvd: 54 Lastly, I was unable to get more information about ports 6000, 6008, and 8111.","title":"Scanning services"},{"location":"research/ssl-pinning/","text":"SSL Pinning # There are several techniques to bypass SSL Pinning, some are easier than others. I am going to use an old Android tablet that runs Android KitKat 4.4. I think that will help me a little bit because that version does not implement Network Security Config which was added in Android 7. Adding custom CA # I am going to add my custom CA so using BurpSuite I'll be able to decrypt the TLS traffic and see it in plain text. As I am running Android 4.4 it should be enough to add the CA in the Keystore. I configured Burp to listen on any interface so when navigating to http://burp from the Android browser I'll be able to install the CA. Setting up RPi # When examining the network traffic and doing some changes it is worth avoiding doing it on your own machine, otherwise, you may get block without an Internet connection. Thus, I configured a Raspberry Pi 4 with Raspbian so I can handle the traffic modifications without any issues on my own machine. The setup is quite easy. First, I'll need an Access Point to connect the tablet to. Second, I need the AP software (hostapd) and a DNS server so I can handle the resolutions at my wish. In terms to configure the DNS responses well an catch them I sniffed the traffic to see what connections was doing the Conga app. At this point, I realized that when opening the application even without being authenticated, the application was doing another connection. This time to cecotec.fas.3irobotix.net:4020 . The data send it to the server was like: 180000000200000000000000000081de383441306e5dd507 180000000200000000000000000082e3383441306e5dd507 180000000200000000000000000083ed383441306e5dd507 180000000200000000000000000084f2383441306e5dd507 180000000200000000000000000085fc383441306e5dd507 I did some tests and I could see most data is static, but some changes. 1800000002000000000000000000 81de38 3441306e5dd507 That highlighted bit changes across requests and every time the application is opened. In particular 1800000002000000000000000000 8 1de 38 3441306e5dd507 changes every time the applications is opened, however, 18000000020000000000000000008 1de 383441306e5dd507 changes on every request. Digging a little bit there is a nibble that its count is sequential, 18000000020000000000000000008 1 de383441306e5dd507. Thus, this can be a kind of request counter or keepalive. As the data seems to be quite different from the usual HTTP protocol I set up a MitM relay so I can grab the traffic send using a different protocol than the HTTP. Doing a quick overview of the data seems to be something. Splitting it up in chunks of 4 bytes long I got 6 blocks. 18 00 00 00 | 02 00 00 00 | 00 00 00 00 | 00 00 84 f2 | 38 34 41 30 | 6e 5d d5 07 Setting up BurpSuite # In BurpSuite I didn't do a lot, basically, I configure a proxy for all interfaces listening at the same port a used in the MitM proxy flag. SSL Pinning # So far so good, but where is the SSL. Well, I am guessing that the BurpSuite CA installed through the browser did the job, as I can see that traffic or it might be in plain text I am not fully sure at this point as I didn't sniff the traffic before installing the CA. What I did to see whether the application uses SSL Pinning was disassembling it. Using ApkTool I could see in the pseudocode that the Cecotec application uses okhttp . That is because they are implementing the SSL Pinning and the BurpSuite CA installed may not be enough. The way I bypass the SSL Pinning is by using Objection . That was the first time I use that tool and what the hell, that is fucking awesome. It can do a lot of crazy things and one of them is bypassing the SSL Pinning. I am not going to explain more as the documentation is really nice and the tool is really easy to use.","title":"SSL Pinning"},{"location":"research/ssl-pinning/#ssl-pinning","text":"There are several techniques to bypass SSL Pinning, some are easier than others. I am going to use an old Android tablet that runs Android KitKat 4.4. I think that will help me a little bit because that version does not implement Network Security Config which was added in Android 7.","title":"SSL Pinning"},{"location":"research/ssl-pinning/#adding-custom-ca","text":"I am going to add my custom CA so using BurpSuite I'll be able to decrypt the TLS traffic and see it in plain text. As I am running Android 4.4 it should be enough to add the CA in the Keystore. I configured Burp to listen on any interface so when navigating to http://burp from the Android browser I'll be able to install the CA.","title":"Adding custom CA"},{"location":"research/ssl-pinning/#setting-up-rpi","text":"When examining the network traffic and doing some changes it is worth avoiding doing it on your own machine, otherwise, you may get block without an Internet connection. Thus, I configured a Raspberry Pi 4 with Raspbian so I can handle the traffic modifications without any issues on my own machine. The setup is quite easy. First, I'll need an Access Point to connect the tablet to. Second, I need the AP software (hostapd) and a DNS server so I can handle the resolutions at my wish. In terms to configure the DNS responses well an catch them I sniffed the traffic to see what connections was doing the Conga app. At this point, I realized that when opening the application even without being authenticated, the application was doing another connection. This time to cecotec.fas.3irobotix.net:4020 . The data send it to the server was like: 180000000200000000000000000081de383441306e5dd507 180000000200000000000000000082e3383441306e5dd507 180000000200000000000000000083ed383441306e5dd507 180000000200000000000000000084f2383441306e5dd507 180000000200000000000000000085fc383441306e5dd507 I did some tests and I could see most data is static, but some changes. 1800000002000000000000000000 81de38 3441306e5dd507 That highlighted bit changes across requests and every time the application is opened. In particular 1800000002000000000000000000 8 1de 38 3441306e5dd507 changes every time the applications is opened, however, 18000000020000000000000000008 1de 383441306e5dd507 changes on every request. Digging a little bit there is a nibble that its count is sequential, 18000000020000000000000000008 1 de383441306e5dd507. Thus, this can be a kind of request counter or keepalive. As the data seems to be quite different from the usual HTTP protocol I set up a MitM relay so I can grab the traffic send using a different protocol than the HTTP. Doing a quick overview of the data seems to be something. Splitting it up in chunks of 4 bytes long I got 6 blocks. 18 00 00 00 | 02 00 00 00 | 00 00 00 00 | 00 00 84 f2 | 38 34 41 30 | 6e 5d d5 07","title":"Setting up RPi"},{"location":"research/ssl-pinning/#setting-up-burpsuite","text":"In BurpSuite I didn't do a lot, basically, I configure a proxy for all interfaces listening at the same port a used in the MitM proxy flag.","title":"Setting up BurpSuite"},{"location":"research/ssl-pinning/#ssl-pinning_1","text":"So far so good, but where is the SSL. Well, I am guessing that the BurpSuite CA installed through the browser did the job, as I can see that traffic or it might be in plain text I am not fully sure at this point as I didn't sniff the traffic before installing the CA. What I did to see whether the application uses SSL Pinning was disassembling it. Using ApkTool I could see in the pseudocode that the Cecotec application uses okhttp . That is because they are implementing the SSL Pinning and the BurpSuite CA installed may not be enough. The way I bypass the SSL Pinning is by using Objection . That was the first time I use that tool and what the hell, that is fucking awesome. It can do a lot of crazy things and one of them is bypassing the SSL Pinning. I am not going to explain more as the documentation is really nice and the tool is really easy to use.","title":"SSL Pinning"},{"location":"research/models/login/","text":"Login # 5490 # Request # message LoginRequest { required string email = 1; required string password = 2; required int32 unknown = 4; // always set as 1003d } Response # // Login failed message LoginResponse { required int32 unknown = 1; required string error = 2; // User password is incorrect(username: <email>) } // Login success message LoginResponse { message Unknown { required int32 unknown1 = 1; required int32 unknown2 = 2; } message Msg { required int32 user_id = 1; required string session_id = 2; required int32 unknown = 3; required int32 unknown1 = 5; required Unknown unknown2 = 6; } required int32 unknown = 1; required Msg msg = 3; }","title":"Login"},{"location":"research/models/login/#login","text":"","title":"Login"},{"location":"research/models/login/#5490","text":"","title":"5490"},{"location":"research/models/login/#request","text":"message LoginRequest { required string email = 1; required string password = 2; required int32 unknown = 4; // always set as 1003d }","title":"Request"},{"location":"research/models/login/#response","text":"// Login failed message LoginResponse { required int32 unknown = 1; required string error = 2; // User password is incorrect(username: <email>) } // Login success message LoginResponse { message Unknown { required int32 unknown1 = 1; required int32 unknown2 = 2; } message Msg { required int32 user_id = 1; required string session_id = 2; required int32 unknown = 3; required int32 unknown1 = 5; required Unknown unknown2 = 6; } required int32 unknown = 1; required Msg msg = 3; }","title":"Response"},{"location":"research/models/ping/","text":"Ping # 5490 # Request # Response #","title":"Ping"},{"location":"research/models/ping/#ping","text":"","title":"Ping"},{"location":"research/models/ping/#5490","text":"","title":"5490"},{"location":"research/models/ping/#request","text":"","title":"Request"},{"location":"research/models/ping/#response","text":"","title":"Response"}]}